{
  "contract_name": "dexter-generator",
  "contract_version": "1.0.0",
  "idl_version": "1.0.0",
  "instantiate": {
    "$schema": "http://json-schema.org/draft-07/schema#",
    "title": "InstantiateMsg",
    "description": "This structure describes the parameters used for creating a contract.",
    "type": "object",
    "required": [
      "owner",
      "start_block",
      "tokens_per_block",
      "unbonding_period",
      "vault"
    ],
    "properties": {
      "dex_token": {
        "description": "DEX token contract address",
        "type": [
          "string",
          "null"
        ]
      },
      "owner": {
        "description": "Address that can change contract settings",
        "type": "string"
      },
      "start_block": {
        "description": "Start block for distributing DEX",
        "allOf": [
          {
            "$ref": "#/definitions/Uint64"
          }
        ]
      },
      "tokens_per_block": {
        "description": "Amount of DEX distributed per block among all pairs",
        "allOf": [
          {
            "$ref": "#/definitions/Uint128"
          }
        ]
      },
      "unbonding_period": {
        "description": "Number of seconds to wait before a user can withdraw his LP tokens once they are in unbonding phase",
        "type": "integer",
        "format": "uint64",
        "minimum": 0.0
      },
      "vault": {
        "description": "Address of vault contract",
        "type": "string"
      }
    },
    "additionalProperties": false,
    "definitions": {
      "Uint128": {
        "description": "A thin wrapper around u128 that is using strings for JSON encoding/decoding, such that the full u128 range can be used for clients that convert JSON numbers to floats, like JavaScript and jq.\n\n# Examples\n\nUse `from` to create instances of this and `u128` to get the value out:\n\n``` # use cosmwasm_std::Uint128; let a = Uint128::from(123u128); assert_eq!(a.u128(), 123);\n\nlet b = Uint128::from(42u64); assert_eq!(b.u128(), 42);\n\nlet c = Uint128::from(70u32); assert_eq!(c.u128(), 70); ```",
        "type": "string"
      },
      "Uint64": {
        "description": "A thin wrapper around u64 that is using strings for JSON encoding/decoding, such that the full u64 range can be used for clients that convert JSON numbers to floats, like JavaScript and jq.\n\n# Examples\n\nUse `from` to create instances of this and `u64` to get the value out:\n\n``` # use cosmwasm_std::Uint64; let a = Uint64::from(42u64); assert_eq!(a.u64(), 42);\n\nlet b = Uint64::from(70u32); assert_eq!(b.u64(), 70); ```",
        "type": "string"
      }
    }
  },
  "execute": {
    "$schema": "http://json-schema.org/draft-07/schema#",
    "title": "ExecuteMsg",
    "oneOf": [
      {
        "description": "Failitates updating some of the configuration param of the Dexter Generator Contract ## Executor -  Only the owner can execute it.",
        "type": "object",
        "required": [
          "update_config"
        ],
        "properties": {
          "update_config": {
            "type": "object",
            "properties": {
              "dex_token": {
                "type": [
                  "string",
                  "null"
                ]
              },
              "unbonding_period": {
                "description": "Number of seconds to wait before a user can withdraw his LP tokens after unbonding. Doesn't update period for existing unbonding positions",
                "type": [
                  "integer",
                  "null"
                ],
                "format": "uint64",
                "minimum": 0.0
              },
              "vesting_contract": {
                "description": "The DEX Vesting contract address",
                "type": [
                  "string",
                  "null"
                ]
              }
            },
            "additionalProperties": false
          }
        },
        "additionalProperties": false
      },
      {
        "description": "Set a new amount of DEX tokens to distribute per block ## Executor - Only the owner can execute this.",
        "type": "object",
        "required": [
          "set_tokens_per_block"
        ],
        "properties": {
          "set_tokens_per_block": {
            "type": "object",
            "required": [
              "amount"
            ],
            "properties": {
              "amount": {
                "description": "The new amount of DEX to distro per block",
                "allOf": [
                  {
                    "$ref": "#/definitions/Uint128"
                  }
                ]
              }
            },
            "additionalProperties": false
          }
        },
        "additionalProperties": false
      },
      {
        "description": "Setup generators with their respective allocation points. ## Executor - Only the owner can execute this.",
        "type": "object",
        "required": [
          "setup_pools"
        ],
        "properties": {
          "setup_pools": {
            "type": "object",
            "required": [
              "pools"
            ],
            "properties": {
              "pools": {
                "description": "The list of pools with allocation point.",
                "type": "array",
                "items": {
                  "type": "array",
                  "items": [
                    {
                      "type": "string"
                    },
                    {
                      "$ref": "#/definitions/Uint128"
                    }
                  ],
                  "maxItems": 2,
                  "minItems": 2
                }
              }
            },
            "additionalProperties": false
          }
        },
        "additionalProperties": false
      },
      {
        "description": "Allowed reward proxy contracts that can interact with the Generator ## Executor - Only the owner can execute this.",
        "type": "object",
        "required": [
          "set_allowed_reward_proxies"
        ],
        "properties": {
          "set_allowed_reward_proxies": {
            "type": "object",
            "required": [
              "proxies"
            ],
            "properties": {
              "proxies": {
                "description": "The full list of allowed proxy contracts",
                "type": "array",
                "items": {
                  "type": "string"
                }
              }
            },
            "additionalProperties": false
          }
        },
        "additionalProperties": false
      },
      {
        "description": "Setup proxies (should be whitelisted) for a generator. ## Executor - Only the owner can execute this.",
        "type": "object",
        "required": [
          "setup_proxy_for_pool"
        ],
        "properties": {
          "setup_proxy_for_pool": {
            "type": "object",
            "required": [
              "lp_token",
              "proxy_addr"
            ],
            "properties": {
              "lp_token": {
                "description": "The list of pools with allocation point.",
                "type": "string"
              },
              "proxy_addr": {
                "type": "string"
              }
            },
            "additionalProperties": false
          }
        },
        "additionalProperties": false
      },
      {
        "description": "Sends orphan proxy rewards (which were left behind after emergency withdrawals) to another address ## Executor - Only the owner can execute this.",
        "type": "object",
        "required": [
          "send_orphan_proxy_reward"
        ],
        "properties": {
          "send_orphan_proxy_reward": {
            "type": "object",
            "required": [
              "lp_token",
              "recipient"
            ],
            "properties": {
              "lp_token": {
                "description": "The address of the LP token contract for which we send orphaned rewards",
                "type": "string"
              },
              "recipient": {
                "description": "The transfer recipient",
                "type": "string"
              }
            },
            "additionalProperties": false
          }
        },
        "additionalProperties": false
      },
      {
        "description": "Add or remove a proxy contract that can interact with the Generator ## Executor - Only the owner can execute this.",
        "type": "object",
        "required": [
          "update_allowed_proxies"
        ],
        "properties": {
          "update_allowed_proxies": {
            "type": "object",
            "properties": {
              "add": {
                "description": "Allowed proxy contract",
                "type": [
                  "array",
                  "null"
                ],
                "items": {
                  "type": "string"
                }
              },
              "remove": {
                "description": "Proxy contracts to remove",
                "type": [
                  "array",
                  "null"
                ],
                "items": {
                  "type": "string"
                }
              }
            },
            "additionalProperties": false
          }
        },
        "additionalProperties": false
      },
      {
        "description": "Sets the allocation point to zero for the specified pool ## Executor -  Only the current owner  can execute this",
        "type": "object",
        "required": [
          "deactivate_pool"
        ],
        "properties": {
          "deactivate_pool": {
            "type": "object",
            "required": [
              "lp_token"
            ],
            "properties": {
              "lp_token": {
                "type": "string"
              }
            },
            "additionalProperties": false
          }
        },
        "additionalProperties": false
      },
      {
        "description": "Update rewards and transfer them to user. ## Executor - Open for users",
        "type": "object",
        "required": [
          "claim_rewards"
        ],
        "properties": {
          "claim_rewards": {
            "type": "object",
            "required": [
              "lp_tokens"
            ],
            "properties": {
              "lp_tokens": {
                "description": "the LP token contract address",
                "type": "array",
                "items": {
                  "type": "string"
                }
              }
            },
            "additionalProperties": false
          }
        },
        "additionalProperties": false
      },
      {
        "description": "Unstake LP tokens from the Generator. LP tokens need to be unbonded for a period of time before they can be withdrawn. ## Executor - Open for users",
        "type": "object",
        "required": [
          "unstake"
        ],
        "properties": {
          "unstake": {
            "type": "object",
            "required": [
              "amount",
              "lp_token"
            ],
            "properties": {
              "amount": {
                "description": "The amount to withdraw",
                "allOf": [
                  {
                    "$ref": "#/definitions/Uint128"
                  }
                ]
              },
              "lp_token": {
                "description": "The address of the LP token to withdraw",
                "type": "string"
              }
            },
            "additionalProperties": false
          }
        },
        "additionalProperties": false
      },
      {
        "description": "Unstake LP tokens from the Generator without withdrawing outstanding rewards.  LP tokens need to be unbonded for a period of time before they can be withdrawn. ## Executor - Open for users",
        "type": "object",
        "required": [
          "emergency_unstake"
        ],
        "properties": {
          "emergency_unstake": {
            "type": "object",
            "required": [
              "lp_token"
            ],
            "properties": {
              "lp_token": {
                "description": "The address of the LP token to withdraw",
                "type": "string"
              }
            },
            "additionalProperties": false
          }
        },
        "additionalProperties": false
      },
      {
        "description": "Unlock and withdraw LP tokens from the Generator ## Executor - Open for users",
        "type": "object",
        "required": [
          "unlock"
        ],
        "properties": {
          "unlock": {
            "type": "object",
            "required": [
              "lp_token"
            ],
            "properties": {
              "lp_token": {
                "description": "The address of the LP token to withdraw",
                "type": "string"
              }
            },
            "additionalProperties": false
          }
        },
        "additionalProperties": false
      },
      {
        "description": "Receives a message of type [`Cw20ReceiveMsg`]",
        "type": "object",
        "required": [
          "receive"
        ],
        "properties": {
          "receive": {
            "$ref": "#/definitions/Cw20ReceiveMsg"
          }
        },
        "additionalProperties": false
      },
      {
        "description": "Creates a request to change contract ownership ## Executor -  Only the current owner can execute this.",
        "type": "object",
        "required": [
          "propose_new_owner"
        ],
        "properties": {
          "propose_new_owner": {
            "type": "object",
            "required": [
              "expires_in",
              "owner"
            ],
            "properties": {
              "expires_in": {
                "description": "The validity period of the proposal to change the contract owner",
                "type": "integer",
                "format": "uint64",
                "minimum": 0.0
              },
              "owner": {
                "description": "The newly proposed owner",
                "type": "string"
              }
            },
            "additionalProperties": false
          }
        },
        "additionalProperties": false
      },
      {
        "description": "Removes a request to change contract ownership ## Executor -  Only the current owner can execute this",
        "type": "object",
        "required": [
          "drop_ownership_proposal"
        ],
        "properties": {
          "drop_ownership_proposal": {
            "type": "object",
            "additionalProperties": false
          }
        },
        "additionalProperties": false
      },
      {
        "description": "Claims contract ownership ## Executor - Only the newly proposed owner can execute this",
        "type": "object",
        "required": [
          "claim_ownership"
        ],
        "properties": {
          "claim_ownership": {
            "type": "object",
            "additionalProperties": false
          }
        },
        "additionalProperties": false
      }
    ],
    "definitions": {
      "Binary": {
        "description": "Binary is a wrapper around Vec<u8> to add base64 de/serialization with serde. It also adds some helper methods to help encode inline.\n\nThis is only needed as serde-json-{core,wasm} has a horrible encoding for Vec<u8>. See also <https://github.com/CosmWasm/cosmwasm/blob/main/docs/MESSAGE_TYPES.md>.",
        "type": "string"
      },
      "Cw20ReceiveMsg": {
        "description": "Cw20ReceiveMsg should be de/serialized under `Receive()` variant in a ExecuteMsg",
        "type": "object",
        "required": [
          "amount",
          "msg",
          "sender"
        ],
        "properties": {
          "amount": {
            "$ref": "#/definitions/Uint128"
          },
          "msg": {
            "$ref": "#/definitions/Binary"
          },
          "sender": {
            "type": "string"
          }
        },
        "additionalProperties": false
      },
      "Uint128": {
        "description": "A thin wrapper around u128 that is using strings for JSON encoding/decoding, such that the full u128 range can be used for clients that convert JSON numbers to floats, like JavaScript and jq.\n\n# Examples\n\nUse `from` to create instances of this and `u128` to get the value out:\n\n``` # use cosmwasm_std::Uint128; let a = Uint128::from(123u128); assert_eq!(a.u128(), 123);\n\nlet b = Uint128::from(42u64); assert_eq!(b.u128(), 42);\n\nlet c = Uint128::from(70u32); assert_eq!(c.u128(), 70); ```",
        "type": "string"
      }
    }
  },
  "query": {
    "$schema": "http://json-schema.org/draft-07/schema#",
    "title": "QueryMsg",
    "oneOf": [
      {
        "description": "Config returns the main contract parameters",
        "type": "object",
        "required": [
          "config"
        ],
        "properties": {
          "config": {
            "type": "object",
            "additionalProperties": false
          }
        },
        "additionalProperties": false
      },
      {
        "description": "Returns the length of the array that contains all the active pool generators",
        "type": "object",
        "required": [
          "active_pool_length"
        ],
        "properties": {
          "active_pool_length": {
            "type": "object",
            "additionalProperties": false
          }
        },
        "additionalProperties": false
      },
      {
        "description": "PoolLength returns the length of the array that contains all the instantiated pool generators",
        "type": "object",
        "required": [
          "pool_length"
        ],
        "properties": {
          "pool_length": {
            "type": "object",
            "additionalProperties": false
          }
        },
        "additionalProperties": false
      },
      {
        "description": "Deposit returns the LP token amount deposited in a specific generator",
        "type": "object",
        "required": [
          "deposit"
        ],
        "properties": {
          "deposit": {
            "type": "object",
            "required": [
              "lp_token",
              "user"
            ],
            "properties": {
              "lp_token": {
                "type": "string"
              },
              "user": {
                "type": "string"
              }
            },
            "additionalProperties": false
          }
        },
        "additionalProperties": false
      },
      {
        "description": "PendingToken returns the amount of rewards that can be claimed by an account that deposited a specific LP token in a generator",
        "type": "object",
        "required": [
          "pending_token"
        ],
        "properties": {
          "pending_token": {
            "type": "object",
            "required": [
              "lp_token",
              "user"
            ],
            "properties": {
              "lp_token": {
                "type": "string"
              },
              "user": {
                "type": "string"
              }
            },
            "additionalProperties": false
          }
        },
        "additionalProperties": false
      },
      {
        "description": "RewardInfo returns reward information for a specified LP token",
        "type": "object",
        "required": [
          "reward_info"
        ],
        "properties": {
          "reward_info": {
            "type": "object",
            "required": [
              "lp_token"
            ],
            "properties": {
              "lp_token": {
                "type": "string"
              }
            },
            "additionalProperties": false
          }
        },
        "additionalProperties": false
      },
      {
        "description": "OrphanProxyRewards returns orphaned reward information for the specified LP token",
        "type": "object",
        "required": [
          "orphan_proxy_rewards"
        ],
        "properties": {
          "orphan_proxy_rewards": {
            "type": "object",
            "required": [
              "lp_token"
            ],
            "properties": {
              "lp_token": {
                "type": "string"
              }
            },
            "additionalProperties": false
          }
        },
        "additionalProperties": false
      },
      {
        "description": "PoolInfo returns information about a pool associated with the specified LP token alongside the total pending amount of DEX and proxy rewards claimable by generator stakers (for that LP token)",
        "type": "object",
        "required": [
          "pool_info"
        ],
        "properties": {
          "pool_info": {
            "type": "object",
            "required": [
              "lp_token"
            ],
            "properties": {
              "lp_token": {
                "type": "string"
              }
            },
            "additionalProperties": false
          }
        },
        "additionalProperties": false
      },
      {
        "type": "object",
        "required": [
          "user_info"
        ],
        "properties": {
          "user_info": {
            "type": "object",
            "required": [
              "lp_token",
              "user"
            ],
            "properties": {
              "lp_token": {
                "type": "string"
              },
              "user": {
                "type": "string"
              }
            },
            "additionalProperties": false
          }
        },
        "additionalProperties": false
      },
      {
        "description": "SimulateFutureReward returns the amount of DEX that will be distributed until a future block and for a specific generator",
        "type": "object",
        "required": [
          "simulate_future_reward"
        ],
        "properties": {
          "simulate_future_reward": {
            "type": "object",
            "required": [
              "future_block",
              "lp_token"
            ],
            "properties": {
              "future_block": {
                "type": "integer",
                "format": "uint64",
                "minimum": 0.0
              },
              "lp_token": {
                "type": "string"
              }
            },
            "additionalProperties": false
          }
        },
        "additionalProperties": false
      }
    ]
  },
  "migrate": {
    "$schema": "http://json-schema.org/draft-07/schema#",
    "title": "MigrateMsg",
    "description": "This structure describes a migration message.",
    "type": "object",
    "additionalProperties": false
  },
  "sudo": null,
  "responses": {
    "active_pool_length": {
      "$schema": "http://json-schema.org/draft-07/schema#",
      "title": "PoolLengthResponse",
      "description": "This structure holds the response returned when querying the total length of the array that keeps track of instantiated generators",
      "type": "object",
      "required": [
        "length"
      ],
      "properties": {
        "length": {
          "type": "integer",
          "format": "uint",
          "minimum": 0.0
        }
      },
      "additionalProperties": false
    },
    "config": {
      "$schema": "http://json-schema.org/draft-07/schema#",
      "title": "ConfigResponse",
      "description": "This structure holds the response returned when querying the contract for general parameters",
      "type": "object",
      "required": [
        "active_pools",
        "allowed_reward_proxies",
        "owner",
        "start_block",
        "tokens_per_block",
        "total_alloc_point",
        "unbonding_period",
        "vault"
      ],
      "properties": {
        "active_pools": {
          "description": "The list of active pools with allocation points",
          "type": "array",
          "items": {
            "type": "array",
            "items": [
              {
                "$ref": "#/definitions/Addr"
              },
              {
                "$ref": "#/definitions/Uint128"
              }
            ],
            "maxItems": 2,
            "minItems": 2
          }
        },
        "allowed_reward_proxies": {
          "description": "List of 3rd party reward proxies allowed to interact with the Generator contract",
          "type": "array",
          "items": {
            "$ref": "#/definitions/Addr"
          }
        },
        "dex_token": {
          "description": "DEX token contract address",
          "anyOf": [
            {
              "$ref": "#/definitions/Addr"
            },
            {
              "type": "null"
            }
          ]
        },
        "owner": {
          "description": "Address that's allowed to change contract parameters",
          "allOf": [
            {
              "$ref": "#/definitions/Addr"
            }
          ]
        },
        "start_block": {
          "description": "Start block for DEX incentives",
          "allOf": [
            {
              "$ref": "#/definitions/Uint64"
            }
          ]
        },
        "tokens_per_block": {
          "description": "Total amount of DEX distributed per block",
          "allOf": [
            {
              "$ref": "#/definitions/Uint128"
            }
          ]
        },
        "total_alloc_point": {
          "description": "Sum of total allocation points across all active generators",
          "allOf": [
            {
              "$ref": "#/definitions/Uint128"
            }
          ]
        },
        "unbonding_period": {
          "description": "Unbonding period",
          "type": "integer",
          "format": "uint64",
          "minimum": 0.0
        },
        "vault": {
          "description": "the Factory address",
          "allOf": [
            {
              "$ref": "#/definitions/Addr"
            }
          ]
        },
        "vesting_contract": {
          "description": "The DEX vesting contract address",
          "anyOf": [
            {
              "$ref": "#/definitions/Addr"
            },
            {
              "type": "null"
            }
          ]
        }
      },
      "additionalProperties": false,
      "definitions": {
        "Addr": {
          "description": "A human readable address.\n\nIn Cosmos, this is typically bech32 encoded. But for multi-chain smart contracts no assumptions should be made other than being UTF-8 encoded and of reasonable length.\n\nThis type represents a validated address. It can be created in the following ways 1. Use `Addr::unchecked(input)` 2. Use `let checked: Addr = deps.api.addr_validate(input)?` 3. Use `let checked: Addr = deps.api.addr_humanize(canonical_addr)?` 4. Deserialize from JSON. This must only be done from JSON that was validated before such as a contract's state. `Addr` must not be used in messages sent by the user because this would result in unvalidated instances.\n\nThis type is immutable. If you really need to mutate it (Really? Are you sure?), create a mutable copy using `let mut mutable = Addr::to_string()` and operate on that `String` instance.",
          "type": "string"
        },
        "Uint128": {
          "description": "A thin wrapper around u128 that is using strings for JSON encoding/decoding, such that the full u128 range can be used for clients that convert JSON numbers to floats, like JavaScript and jq.\n\n# Examples\n\nUse `from` to create instances of this and `u128` to get the value out:\n\n``` # use cosmwasm_std::Uint128; let a = Uint128::from(123u128); assert_eq!(a.u128(), 123);\n\nlet b = Uint128::from(42u64); assert_eq!(b.u128(), 42);\n\nlet c = Uint128::from(70u32); assert_eq!(c.u128(), 70); ```",
          "type": "string"
        },
        "Uint64": {
          "description": "A thin wrapper around u64 that is using strings for JSON encoding/decoding, such that the full u64 range can be used for clients that convert JSON numbers to floats, like JavaScript and jq.\n\n# Examples\n\nUse `from` to create instances of this and `u64` to get the value out:\n\n``` # use cosmwasm_std::Uint64; let a = Uint64::from(42u64); assert_eq!(a.u64(), 42);\n\nlet b = Uint64::from(70u32); assert_eq!(b.u64(), 70); ```",
          "type": "string"
        }
      }
    },
    "deposit": {
      "$schema": "http://json-schema.org/draft-07/schema#",
      "title": "Uint128",
      "description": "A thin wrapper around u128 that is using strings for JSON encoding/decoding, such that the full u128 range can be used for clients that convert JSON numbers to floats, like JavaScript and jq.\n\n# Examples\n\nUse `from` to create instances of this and `u128` to get the value out:\n\n``` # use cosmwasm_std::Uint128; let a = Uint128::from(123u128); assert_eq!(a.u128(), 123);\n\nlet b = Uint128::from(42u64); assert_eq!(b.u128(), 42);\n\nlet c = Uint128::from(70u32); assert_eq!(c.u128(), 70); ```",
      "type": "string"
    },
    "orphan_proxy_rewards": {
      "$schema": "http://json-schema.org/draft-07/schema#",
      "title": "Tuple_of_AssetInfo_and_Uint128",
      "type": "array",
      "items": [
        {
          "$ref": "#/definitions/AssetInfo"
        },
        {
          "$ref": "#/definitions/Uint128"
        }
      ],
      "maxItems": 2,
      "minItems": 2,
      "definitions": {
        "Addr": {
          "description": "A human readable address.\n\nIn Cosmos, this is typically bech32 encoded. But for multi-chain smart contracts no assumptions should be made other than being UTF-8 encoded and of reasonable length.\n\nThis type represents a validated address. It can be created in the following ways 1. Use `Addr::unchecked(input)` 2. Use `let checked: Addr = deps.api.addr_validate(input)?` 3. Use `let checked: Addr = deps.api.addr_humanize(canonical_addr)?` 4. Deserialize from JSON. This must only be done from JSON that was validated before such as a contract's state. `Addr` must not be used in messages sent by the user because this would result in unvalidated instances.\n\nThis type is immutable. If you really need to mutate it (Really? Are you sure?), create a mutable copy using `let mut mutable = Addr::to_string()` and operate on that `String` instance.",
          "type": "string"
        },
        "AssetInfo": {
          "description": "This enum describes available Token types.",
          "oneOf": [
            {
              "description": "Non-native Token",
              "type": "object",
              "required": [
                "token"
              ],
              "properties": {
                "token": {
                  "type": "object",
                  "required": [
                    "contract_addr"
                  ],
                  "properties": {
                    "contract_addr": {
                      "$ref": "#/definitions/Addr"
                    }
                  },
                  "additionalProperties": false
                }
              },
              "additionalProperties": false
            },
            {
              "description": "Native token",
              "type": "object",
              "required": [
                "native_token"
              ],
              "properties": {
                "native_token": {
                  "type": "object",
                  "required": [
                    "denom"
                  ],
                  "properties": {
                    "denom": {
                      "type": "string"
                    }
                  },
                  "additionalProperties": false
                }
              },
              "additionalProperties": false
            }
          ]
        },
        "Uint128": {
          "description": "A thin wrapper around u128 that is using strings for JSON encoding/decoding, such that the full u128 range can be used for clients that convert JSON numbers to floats, like JavaScript and jq.\n\n# Examples\n\nUse `from` to create instances of this and `u128` to get the value out:\n\n``` # use cosmwasm_std::Uint128; let a = Uint128::from(123u128); assert_eq!(a.u128(), 123);\n\nlet b = Uint128::from(42u64); assert_eq!(b.u128(), 42);\n\nlet c = Uint128::from(70u32); assert_eq!(c.u128(), 70); ```",
          "type": "string"
        }
      }
    },
    "pending_token": {
      "$schema": "http://json-schema.org/draft-07/schema#",
      "title": "PendingTokenResponse",
      "description": "This structure holds the response returned when querying the amount of pending rewards that can be withdrawn from a 3rd party rewards contract",
      "type": "object",
      "required": [
        "pending"
      ],
      "properties": {
        "pending": {
          "description": "The amount of pending DEX",
          "allOf": [
            {
              "$ref": "#/definitions/Uint128"
            }
          ]
        },
        "pending_on_proxy": {
          "description": "a pending token on proxy",
          "anyOf": [
            {
              "$ref": "#/definitions/Uint128"
            },
            {
              "type": "null"
            }
          ]
        }
      },
      "additionalProperties": false,
      "definitions": {
        "Uint128": {
          "description": "A thin wrapper around u128 that is using strings for JSON encoding/decoding, such that the full u128 range can be used for clients that convert JSON numbers to floats, like JavaScript and jq.\n\n# Examples\n\nUse `from` to create instances of this and `u128` to get the value out:\n\n``` # use cosmwasm_std::Uint128; let a = Uint128::from(123u128); assert_eq!(a.u128(), 123);\n\nlet b = Uint128::from(42u64); assert_eq!(b.u128(), 42);\n\nlet c = Uint128::from(70u32); assert_eq!(c.u128(), 70); ```",
          "type": "string"
        }
      }
    },
    "pool_info": {
      "$schema": "http://json-schema.org/draft-07/schema#",
      "title": "PoolInfoResponse",
      "description": "This structure holds the response returned when querying for a pool's information",
      "type": "object",
      "required": [
        "accumulated_proxy_rewards_per_share",
        "alloc_point",
        "current_block",
        "dex_tokens_per_block",
        "global_reward_index",
        "last_reward_block",
        "lp_supply",
        "orphan_proxy_rewards",
        "pending_dex_rewards",
        "proxy_reward_balance_before_update"
      ],
      "properties": {
        "accumulated_proxy_rewards_per_share": {
          "description": "Total amount of 3rd party token rewards already accumulated per LP token staked per proxy",
          "allOf": [
            {
              "$ref": "#/definitions/Decimal"
            }
          ]
        },
        "alloc_point": {
          "description": "The slice of DEX that this pool's generator gets per block",
          "allOf": [
            {
              "$ref": "#/definitions/Uint128"
            }
          ]
        },
        "current_block": {
          "description": "Current block number. Useful for computing APRs off-chain",
          "type": "integer",
          "format": "uint64",
          "minimum": 0.0
        },
        "dex_tokens_per_block": {
          "description": "Amount of DEX tokens being distributed per block to this LP pool",
          "allOf": [
            {
              "$ref": "#/definitions/Uint128"
            }
          ]
        },
        "global_reward_index": {
          "description": "Total amount of DEX rewards already accumulated per LP token staked",
          "allOf": [
            {
              "$ref": "#/definitions/Decimal"
            }
          ]
        },
        "last_reward_block": {
          "description": "The last block when token emissions were snapshotted (distributed)",
          "type": "integer",
          "format": "uint64",
          "minimum": 0.0
        },
        "lp_supply": {
          "description": "Total amount of lp tokens staked in the pool's generator",
          "allOf": [
            {
              "$ref": "#/definitions/Uint128"
            }
          ]
        },
        "orphan_proxy_rewards": {
          "description": "The amount of orphan proxy rewards which are left behind by emergency withdrawals and not yet transferred out",
          "allOf": [
            {
              "$ref": "#/definitions/Uint128"
            }
          ]
        },
        "pending_dex_rewards": {
          "description": "Pending amount of total DEX rewards which are claimable by stakers right now",
          "allOf": [
            {
              "$ref": "#/definitions/Uint128"
            }
          ]
        },
        "pending_proxy_rewards": {
          "description": "Pending amount of total proxy rewards which are claimable by stakers right now",
          "anyOf": [
            {
              "$ref": "#/definitions/Uint128"
            },
            {
              "type": "null"
            }
          ]
        },
        "proxy_reward_balance_before_update": {
          "description": "Reward balance for the dual rewards proxy before updating accrued rewards",
          "allOf": [
            {
              "$ref": "#/definitions/Uint128"
            }
          ]
        },
        "reward_proxy": {
          "description": "The address of the 3rd party reward proxy contract",
          "anyOf": [
            {
              "$ref": "#/definitions/Addr"
            },
            {
              "type": "null"
            }
          ]
        }
      },
      "additionalProperties": false,
      "definitions": {
        "Addr": {
          "description": "A human readable address.\n\nIn Cosmos, this is typically bech32 encoded. But for multi-chain smart contracts no assumptions should be made other than being UTF-8 encoded and of reasonable length.\n\nThis type represents a validated address. It can be created in the following ways 1. Use `Addr::unchecked(input)` 2. Use `let checked: Addr = deps.api.addr_validate(input)?` 3. Use `let checked: Addr = deps.api.addr_humanize(canonical_addr)?` 4. Deserialize from JSON. This must only be done from JSON that was validated before such as a contract's state. `Addr` must not be used in messages sent by the user because this would result in unvalidated instances.\n\nThis type is immutable. If you really need to mutate it (Really? Are you sure?), create a mutable copy using `let mut mutable = Addr::to_string()` and operate on that `String` instance.",
          "type": "string"
        },
        "Decimal": {
          "description": "A fixed-point decimal value with 18 fractional digits, i.e. Decimal(1_000_000_000_000_000_000) == 1.0\n\nThe greatest possible value that can be represented is 340282366920938463463.374607431768211455 (which is (2^128 - 1) / 10^18)",
          "type": "string"
        },
        "Uint128": {
          "description": "A thin wrapper around u128 that is using strings for JSON encoding/decoding, such that the full u128 range can be used for clients that convert JSON numbers to floats, like JavaScript and jq.\n\n# Examples\n\nUse `from` to create instances of this and `u128` to get the value out:\n\n``` # use cosmwasm_std::Uint128; let a = Uint128::from(123u128); assert_eq!(a.u128(), 123);\n\nlet b = Uint128::from(42u64); assert_eq!(b.u128(), 42);\n\nlet c = Uint128::from(70u32); assert_eq!(c.u128(), 70); ```",
          "type": "string"
        }
      }
    },
    "pool_length": {
      "$schema": "http://json-schema.org/draft-07/schema#",
      "title": "PoolLengthResponse",
      "description": "This structure holds the response returned when querying the total length of the array that keeps track of instantiated generators",
      "type": "object",
      "required": [
        "length"
      ],
      "properties": {
        "length": {
          "type": "integer",
          "format": "uint",
          "minimum": 0.0
        }
      },
      "additionalProperties": false
    },
    "reward_info": {
      "$schema": "http://json-schema.org/draft-07/schema#",
      "title": "RewardInfoResponse",
      "description": "This structure holds the response returned when querying for the token addresses used to reward a specific generator",
      "type": "object",
      "properties": {
        "base_reward_token": {
          "description": "The address of the base reward token",
          "anyOf": [
            {
              "$ref": "#/definitions/Addr"
            },
            {
              "type": "null"
            }
          ]
        },
        "proxy_reward_token": {
          "description": "The address of the 3rd party reward token",
          "anyOf": [
            {
              "$ref": "#/definitions/Addr"
            },
            {
              "type": "null"
            }
          ]
        }
      },
      "additionalProperties": false,
      "definitions": {
        "Addr": {
          "description": "A human readable address.\n\nIn Cosmos, this is typically bech32 encoded. But for multi-chain smart contracts no assumptions should be made other than being UTF-8 encoded and of reasonable length.\n\nThis type represents a validated address. It can be created in the following ways 1. Use `Addr::unchecked(input)` 2. Use `let checked: Addr = deps.api.addr_validate(input)?` 3. Use `let checked: Addr = deps.api.addr_humanize(canonical_addr)?` 4. Deserialize from JSON. This must only be done from JSON that was validated before such as a contract's state. `Addr` must not be used in messages sent by the user because this would result in unvalidated instances.\n\nThis type is immutable. If you really need to mutate it (Really? Are you sure?), create a mutable copy using `let mut mutable = Addr::to_string()` and operate on that `String` instance.",
          "type": "string"
        }
      }
    },
    "simulate_future_reward": {
      "$schema": "http://json-schema.org/draft-07/schema#",
      "title": "Uint128",
      "description": "A thin wrapper around u128 that is using strings for JSON encoding/decoding, such that the full u128 range can be used for clients that convert JSON numbers to floats, like JavaScript and jq.\n\n# Examples\n\nUse `from` to create instances of this and `u128` to get the value out:\n\n``` # use cosmwasm_std::Uint128; let a = Uint128::from(123u128); assert_eq!(a.u128(), 123);\n\nlet b = Uint128::from(42u64); assert_eq!(b.u128(), 42);\n\nlet c = Uint128::from(70u32); assert_eq!(c.u128(), 70); ```",
      "type": "string"
    },
    "user_info": {
      "$schema": "http://json-schema.org/draft-07/schema#",
      "title": "UserInfo",
      "description": "This structure stores the outstanding amount of token rewards that a user accrued. Currently the contract works with UserInfoV2 structure, but this structure is kept for compatibility with the old version.",
      "type": "object",
      "required": [
        "amount",
        "reward_debt",
        "reward_debt_proxy",
        "unbonding_periods"
      ],
      "properties": {
        "amount": {
          "description": "The amount of LP tokens staked",
          "allOf": [
            {
              "$ref": "#/definitions/Uint128"
            }
          ]
        },
        "reward_debt": {
          "description": "The amount of DEX rewards a user already received or is not eligible for; used for proper reward calculation",
          "allOf": [
            {
              "$ref": "#/definitions/Uint128"
            }
          ]
        },
        "reward_debt_proxy": {
          "description": "Proxy reward amount a user already received per reward proxy; used for proper reward calculation",
          "allOf": [
            {
              "$ref": "#/definitions/Uint128"
            }
          ]
        },
        "unbonding_periods": {
          "description": "Vector containing unbonding information for each unbonding period.",
          "type": "array",
          "items": {
            "$ref": "#/definitions/UnbondingInfo"
          }
        }
      },
      "additionalProperties": false,
      "definitions": {
        "Uint128": {
          "description": "A thin wrapper around u128 that is using strings for JSON encoding/decoding, such that the full u128 range can be used for clients that convert JSON numbers to floats, like JavaScript and jq.\n\n# Examples\n\nUse `from` to create instances of this and `u128` to get the value out:\n\n``` # use cosmwasm_std::Uint128; let a = Uint128::from(123u128); assert_eq!(a.u128(), 123);\n\nlet b = Uint128::from(42u64); assert_eq!(b.u128(), 42);\n\nlet c = Uint128::from(70u32); assert_eq!(c.u128(), 70); ```",
          "type": "string"
        },
        "UnbondingInfo": {
          "description": "This structure stores the outstanding amount of token rewards that a user accrued. Currently the contract works with UserInfoV2 structure, but this structure is kept for compatibility with the old version.",
          "type": "object",
          "required": [
            "amount",
            "unlock_timestamp"
          ],
          "properties": {
            "amount": {
              "description": "The amount of LP tokens being unbonded",
              "allOf": [
                {
                  "$ref": "#/definitions/Uint128"
                }
              ]
            },
            "unlock_timestamp": {
              "description": "Timestamp at which the unbonding period will end adn the tokens become claimable by the user",
              "type": "integer",
              "format": "uint64",
              "minimum": 0.0
            }
          },
          "additionalProperties": false
        }
      }
    }
  }
}
