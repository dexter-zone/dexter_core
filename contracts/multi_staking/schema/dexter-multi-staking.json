{
  "contract_name": "dexter-multi-staking",
  "contract_version": "1.0.0",
  "idl_version": "1.0.0",
  "instantiate": {
    "$schema": "http://json-schema.org/draft-07/schema#",
    "title": "InstantiateMsg",
    "type": "object",
    "required": [
      "instant_unbond_fee_bp",
      "minimum_reward_schedule_proposal_start_delay",
      "owner",
      "unlock_period"
    ],
    "properties": {
      "instant_unbond_fee_bp": {
        "description": "value between 0 and 1000 (0% to 10%) are allowed",
        "type": "integer",
        "format": "uint64",
        "minimum": 0.0
      },
      "keeper_addr": {
        "anyOf": [
          {
            "$ref": "#/definitions/Addr"
          },
          {
            "type": "null"
          }
        ]
      },
      "minimum_reward_schedule_proposal_start_delay": {
        "type": "integer",
        "format": "uint64",
        "minimum": 0.0
      },
      "owner": {
        "$ref": "#/definitions/Addr"
      },
      "unlock_period": {
        "type": "integer",
        "format": "uint64",
        "minimum": 0.0
      }
    },
    "additionalProperties": false,
    "definitions": {
      "Addr": {
        "description": "A human readable address.\n\nIn Cosmos, this is typically bech32 encoded. But for multi-chain smart contracts no assumptions should be made other than being UTF-8 encoded and of reasonable length.\n\nThis type represents a validated address. It can be created in the following ways 1. Use `Addr::unchecked(input)` 2. Use `let checked: Addr = deps.api.addr_validate(input)?` 3. Use `let checked: Addr = deps.api.addr_humanize(canonical_addr)?` 4. Deserialize from JSON. This must only be done from JSON that was validated before such as a contract's state. `Addr` must not be used in messages sent by the user because this would result in unvalidated instances.\n\nThis type is immutable. If you really need to mutate it (Really? Are you sure?), create a mutable copy using `let mut mutable = Addr::to_string()` and operate on that `String` instance.",
        "type": "string"
      }
    }
  },
  "execute": {
    "$schema": "http://json-schema.org/draft-07/schema#",
    "title": "ExecuteMsg",
    "oneOf": [
      {
        "description": "Allows an admin to update config params",
        "type": "object",
        "required": [
          "update_config"
        ],
        "properties": {
          "update_config": {
            "type": "object",
            "properties": {
              "minimum_reward_schedule_proposal_start_delay": {
                "type": [
                  "integer",
                  "null"
                ],
                "format": "uint64",
                "minimum": 0.0
              },
              "unlock_period": {
                "type": [
                  "integer",
                  "null"
                ],
                "format": "uint64",
                "minimum": 0.0
              }
            },
            "additionalProperties": false
          }
        },
        "additionalProperties": false
      },
      {
        "description": "Proposes a new reward schedule for rewarding LP token holders a specific asset. Asset is distributed linearly over the duration of the reward schedule. This entry point is strictly meant for proposing reward schedules with native tokens. For proposing reward schedules with CW20 tokens, CW20 transfer with ProposeRewardSchedule HookMsg is used. Anyone can initiate a reward schedule proposal.",
        "type": "object",
        "required": [
          "propose_reward_schedule"
        ],
        "properties": {
          "propose_reward_schedule": {
            "type": "object",
            "required": [
              "end_block_time",
              "lp_token",
              "start_block_time",
              "title"
            ],
            "properties": {
              "description": {
                "type": [
                  "string",
                  "null"
                ]
              },
              "end_block_time": {
                "type": "integer",
                "format": "uint64",
                "minimum": 0.0
              },
              "lp_token": {
                "$ref": "#/definitions/Addr"
              },
              "start_block_time": {
                "type": "integer",
                "format": "uint64",
                "minimum": 0.0
              },
              "title": {
                "type": "string"
              }
            },
            "additionalProperties": false
          }
        },
        "additionalProperties": false
      },
      {
        "description": "Only the multi-staking admin can approve/reject proposed reward schedules.",
        "type": "object",
        "required": [
          "review_reward_schedule_proposals"
        ],
        "properties": {
          "review_reward_schedule_proposals": {
            "type": "object",
            "required": [
              "reviews"
            ],
            "properties": {
              "reviews": {
                "type": "array",
                "items": {
                  "$ref": "#/definitions/ReviewProposedRewardSchedule"
                }
              }
            },
            "additionalProperties": false
          }
        },
        "additionalProperties": false
      },
      {
        "description": "Only the proposer can drop the proposal. A proposal can be dropped either if its not yet been reviewed or has been rejected by admin. If approved, a proposal can't be dropped.",
        "type": "object",
        "required": [
          "drop_reward_schedule_proposal"
        ],
        "properties": {
          "drop_reward_schedule_proposal": {
            "type": "object",
            "required": [
              "proposal_id"
            ],
            "properties": {
              "proposal_id": {
                "type": "integer",
                "format": "uint64",
                "minimum": 0.0
              }
            },
            "additionalProperties": false
          }
        },
        "additionalProperties": false
      },
      {
        "description": "Allows an admin to allow a new LP token to be rewarded This is needed to prevent spam related to adding new reward schedules for random LP tokens",
        "type": "object",
        "required": [
          "allow_lp_token"
        ],
        "properties": {
          "allow_lp_token": {
            "type": "object",
            "required": [
              "lp_token"
            ],
            "properties": {
              "lp_token": {
                "$ref": "#/definitions/Addr"
              }
            },
            "additionalProperties": false
          }
        },
        "additionalProperties": false
      },
      {
        "description": ". Allows an admin to remove an LP token from being rewarded. Existing reward schedules for the LP token will still be valid.",
        "type": "object",
        "required": [
          "remove_lp_token"
        ],
        "properties": {
          "remove_lp_token": {
            "type": "object",
            "required": [
              "lp_token"
            ],
            "properties": {
              "lp_token": {
                "$ref": "#/definitions/Addr"
              }
            },
            "additionalProperties": false
          }
        },
        "additionalProperties": false
      },
      {
        "description": "Allows the contract to receive CW20 tokens. The contract can receive CW20 tokens from LP tokens for staking and CW20 assets to be used as rewards.",
        "type": "object",
        "required": [
          "receive"
        ],
        "properties": {
          "receive": {
            "$ref": "#/definitions/Cw20ReceiveMsg"
          }
        },
        "additionalProperties": false
      },
      {
        "description": "Allows to bond LP tokens to the contract. Bonded tokens are eligible to receive rewards.",
        "type": "object",
        "required": [
          "bond"
        ],
        "properties": {
          "bond": {
            "type": "object",
            "required": [
              "amount",
              "lp_token"
            ],
            "properties": {
              "amount": {
                "$ref": "#/definitions/Uint128"
              },
              "lp_token": {
                "$ref": "#/definitions/Addr"
              }
            },
            "additionalProperties": false
          }
        },
        "additionalProperties": false
      },
      {
        "description": "Allows to unbond LP tokens from the contract. After unbonding, the tokens are still locked for a locking period. During this period, the tokens are not eligible to receive rewards. After the locking period, the tokens can be withdrawn.",
        "type": "object",
        "required": [
          "unbond"
        ],
        "properties": {
          "unbond": {
            "type": "object",
            "required": [
              "lp_token"
            ],
            "properties": {
              "amount": {
                "anyOf": [
                  {
                    "$ref": "#/definitions/Uint128"
                  },
                  {
                    "type": "null"
                  }
                ]
              },
              "lp_token": {
                "$ref": "#/definitions/Addr"
              }
            },
            "additionalProperties": false
          }
        },
        "additionalProperties": false
      },
      {
        "description": "Instantly unbonds LP tokens from the contract. No locking period is applied. The tokens are withdrawn from the contract and sent to the user. A penalty is applied to the amount being unbonded. The penalty is calculated as a percentage of the amount being unbonded and sent to the contract keeper as a fee.",
        "type": "object",
        "required": [
          "instant_unbond"
        ],
        "properties": {
          "instant_unbond": {
            "type": "object",
            "required": [
              "amount",
              "lp_token"
            ],
            "properties": {
              "amount": {
                "$ref": "#/definitions/Uint128"
              },
              "lp_token": {
                "$ref": "#/definitions/Addr"
              }
            },
            "additionalProperties": false
          }
        },
        "additionalProperties": false
      },
      {
        "description": "Unlocks the tokens which are locked for a locking period. After unlocking, the tokens are withdrawn from the contract and sent to the user.",
        "type": "object",
        "required": [
          "unlock"
        ],
        "properties": {
          "unlock": {
            "type": "object",
            "required": [
              "lp_token"
            ],
            "properties": {
              "lp_token": {
                "$ref": "#/definitions/Addr"
              }
            },
            "additionalProperties": false
          }
        },
        "additionalProperties": false
      },
      {
        "description": "Instant unlock is a extension of instant unbonding feature which allows to insantly unbond tokens which are in a locked state post normal unbonding. This is useful when a user mistakenly unbonded the tokens instead of instant unbonding or if a black swan event occurs and the user has the LP tokens in a locked state after unbonding. Penalty fee is same as instant unbonding.",
        "type": "object",
        "required": [
          "instant_unlock"
        ],
        "properties": {
          "instant_unlock": {
            "type": "object",
            "required": [
              "lp_token",
              "token_lock_ids"
            ],
            "properties": {
              "lp_token": {
                "$ref": "#/definitions/Addr"
              },
              "token_lock_ids": {
                "type": "array",
                "items": {
                  "type": "integer",
                  "format": "uint64",
                  "minimum": 0.0
                }
              }
            },
            "additionalProperties": false
          }
        },
        "additionalProperties": false
      },
      {
        "description": "Allows to withdraw unbonded rewards for a specific LP token. The rewards are sent to the user's address.",
        "type": "object",
        "required": [
          "withdraw"
        ],
        "properties": {
          "withdraw": {
            "type": "object",
            "required": [
              "lp_token"
            ],
            "properties": {
              "lp_token": {
                "$ref": "#/definitions/Addr"
              }
            },
            "additionalProperties": false
          }
        },
        "additionalProperties": false
      },
      {
        "description": "Allows a reward schedule creator to claim back amount that was not allocated to anyone since no token were bonded. This can only be claimed after reward schedule expiry",
        "type": "object",
        "required": [
          "claim_unallocated_reward"
        ],
        "properties": {
          "claim_unallocated_reward": {
            "type": "object",
            "required": [
              "reward_schedule_id"
            ],
            "properties": {
              "reward_schedule_id": {
                "type": "integer",
                "format": "uint64",
                "minimum": 0.0
              }
            },
            "additionalProperties": false
          }
        },
        "additionalProperties": false
      },
      {
        "description": "Allows the owner to transfer ownership to a new address. Ownership transfer is done in two steps: 1. The owner proposes a new owner. 2. The new owner accepts the ownership. The proposal expires after a certain period of time within which the new owner must accept the ownership.",
        "type": "object",
        "required": [
          "propose_new_owner"
        ],
        "properties": {
          "propose_new_owner": {
            "type": "object",
            "required": [
              "expires_in",
              "owner"
            ],
            "properties": {
              "expires_in": {
                "type": "integer",
                "format": "uint64",
                "minimum": 0.0
              },
              "owner": {
                "$ref": "#/definitions/Addr"
              }
            },
            "additionalProperties": false
          }
        },
        "additionalProperties": false
      },
      {
        "description": "Allows the new owner to accept ownership.",
        "type": "object",
        "required": [
          "claim_ownership"
        ],
        "properties": {
          "claim_ownership": {
            "type": "object",
            "additionalProperties": false
          }
        },
        "additionalProperties": false
      },
      {
        "description": "Allows the owner to drop the ownership transfer proposal.",
        "type": "object",
        "required": [
          "drop_ownership_proposal"
        ],
        "properties": {
          "drop_ownership_proposal": {
            "type": "object",
            "additionalProperties": false
          }
        },
        "additionalProperties": false
      }
    ],
    "definitions": {
      "Addr": {
        "description": "A human readable address.\n\nIn Cosmos, this is typically bech32 encoded. But for multi-chain smart contracts no assumptions should be made other than being UTF-8 encoded and of reasonable length.\n\nThis type represents a validated address. It can be created in the following ways 1. Use `Addr::unchecked(input)` 2. Use `let checked: Addr = deps.api.addr_validate(input)?` 3. Use `let checked: Addr = deps.api.addr_humanize(canonical_addr)?` 4. Deserialize from JSON. This must only be done from JSON that was validated before such as a contract's state. `Addr` must not be used in messages sent by the user because this would result in unvalidated instances.\n\nThis type is immutable. If you really need to mutate it (Really? Are you sure?), create a mutable copy using `let mut mutable = Addr::to_string()` and operate on that `String` instance.",
        "type": "string"
      },
      "Binary": {
        "description": "Binary is a wrapper around Vec<u8> to add base64 de/serialization with serde. It also adds some helper methods to help encode inline.\n\nThis is only needed as serde-json-{core,wasm} has a horrible encoding for Vec<u8>. See also <https://github.com/CosmWasm/cosmwasm/blob/main/docs/MESSAGE_TYPES.md>.",
        "type": "string"
      },
      "Cw20ReceiveMsg": {
        "description": "Cw20ReceiveMsg should be de/serialized under `Receive()` variant in a ExecuteMsg",
        "type": "object",
        "required": [
          "amount",
          "msg",
          "sender"
        ],
        "properties": {
          "amount": {
            "$ref": "#/definitions/Uint128"
          },
          "msg": {
            "$ref": "#/definitions/Binary"
          },
          "sender": {
            "type": "string"
          }
        },
        "additionalProperties": false
      },
      "ReviewProposedRewardSchedule": {
        "description": "Review of a proposed reward schedule for a LP token",
        "type": "object",
        "required": [
          "approve",
          "proposal_id"
        ],
        "properties": {
          "approve": {
            "description": "true if approved, false if rejected",
            "type": "boolean"
          },
          "proposal_id": {
            "description": "ID of the proposal to review",
            "type": "integer",
            "format": "uint64",
            "minimum": 0.0
          }
        },
        "additionalProperties": false
      },
      "Uint128": {
        "description": "A thin wrapper around u128 that is using strings for JSON encoding/decoding, such that the full u128 range can be used for clients that convert JSON numbers to floats, like JavaScript and jq.\n\n# Examples\n\nUse `from` to create instances of this and `u128` to get the value out:\n\n``` # use cosmwasm_std::Uint128; let a = Uint128::from(123u128); assert_eq!(a.u128(), 123);\n\nlet b = Uint128::from(42u64); assert_eq!(b.u128(), 42);\n\nlet c = Uint128::from(70u32); assert_eq!(c.u128(), 70); ```",
        "type": "string"
      }
    }
  },
  "query": {
    "$schema": "http://json-schema.org/draft-07/schema#",
    "title": "QueryMsg",
    "oneOf": [
      {
        "description": "Returns current config of the contract",
        "type": "object",
        "required": [
          "config"
        ],
        "properties": {
          "config": {
            "type": "object",
            "additionalProperties": false
          }
        },
        "additionalProperties": false
      },
      {
        "description": "Returns currently unclaimed rewards for a user for a give LP token If a future block time is provided, it will return the unclaimed rewards till that block time.",
        "type": "object",
        "required": [
          "unclaimed_rewards"
        ],
        "properties": {
          "unclaimed_rewards": {
            "type": "object",
            "required": [
              "lp_token",
              "user"
            ],
            "properties": {
              "block_time": {
                "type": [
                  "integer",
                  "null"
                ],
                "format": "uint64",
                "minimum": 0.0
              },
              "lp_token": {
                "$ref": "#/definitions/Addr"
              },
              "user": {
                "$ref": "#/definitions/Addr"
              }
            },
            "additionalProperties": false
          }
        },
        "additionalProperties": false
      },
      {
        "description": "Returns current token locks for a user for a given LP token If a future block time is provided, it will return the token locks and unlocked value at that block time based on current unlock period",
        "type": "object",
        "required": [
          "token_locks"
        ],
        "properties": {
          "token_locks": {
            "type": "object",
            "required": [
              "lp_token",
              "user"
            ],
            "properties": {
              "block_time": {
                "type": [
                  "integer",
                  "null"
                ],
                "format": "uint64",
                "minimum": 0.0
              },
              "lp_token": {
                "$ref": "#/definitions/Addr"
              },
              "user": {
                "$ref": "#/definitions/Addr"
              }
            },
            "additionalProperties": false
          }
        },
        "additionalProperties": false
      },
      {
        "description": "Returns the total staked amount for a given LP token",
        "type": "object",
        "required": [
          "bonded_lp_tokens"
        ],
        "properties": {
          "bonded_lp_tokens": {
            "type": "object",
            "required": [
              "lp_token",
              "user"
            ],
            "properties": {
              "lp_token": {
                "$ref": "#/definitions/Addr"
              },
              "user": {
                "$ref": "#/definitions/Addr"
              }
            },
            "additionalProperties": false
          }
        },
        "additionalProperties": false
      },
      {
        "description": "Returns the LP tokens which are whitelisted for rewards",
        "type": "object",
        "required": [
          "allowed_l_p_tokens_for_reward"
        ],
        "properties": {
          "allowed_l_p_tokens_for_reward": {
            "type": "object",
            "additionalProperties": false
          }
        },
        "additionalProperties": false
      },
      {
        "description": "Returns the current owner of the contract",
        "type": "object",
        "required": [
          "owner"
        ],
        "properties": {
          "owner": {
            "type": "object",
            "additionalProperties": false
          }
        },
        "additionalProperties": false
      },
      {
        "description": "Returns the proposed reward schedules matching the given pagination params.",
        "type": "object",
        "required": [
          "proposed_reward_schedules"
        ],
        "properties": {
          "proposed_reward_schedules": {
            "type": "object",
            "properties": {
              "limit": {
                "type": [
                  "integer",
                  "null"
                ],
                "format": "uint32",
                "minimum": 0.0
              },
              "start_after": {
                "type": [
                  "integer",
                  "null"
                ],
                "format": "uint64",
                "minimum": 0.0
              }
            },
            "additionalProperties": false
          }
        },
        "additionalProperties": false
      },
      {
        "description": "Returns the proposed reward schedule matching the given proposal_id",
        "type": "object",
        "required": [
          "proposed_reward_schedule"
        ],
        "properties": {
          "proposed_reward_schedule": {
            "type": "object",
            "required": [
              "proposal_id"
            ],
            "properties": {
              "proposal_id": {
                "type": "integer",
                "format": "uint64",
                "minimum": 0.0
              }
            },
            "additionalProperties": false
          }
        },
        "additionalProperties": false
      },
      {
        "description": "Returns the reward schedule for a given LP token and a reward asset",
        "type": "object",
        "required": [
          "reward_schedules"
        ],
        "properties": {
          "reward_schedules": {
            "type": "object",
            "required": [
              "asset",
              "lp_token"
            ],
            "properties": {
              "asset": {
                "$ref": "#/definitions/AssetInfo"
              },
              "lp_token": {
                "$ref": "#/definitions/Addr"
              }
            },
            "additionalProperties": false
          }
        },
        "additionalProperties": false
      },
      {
        "description": "Returns the current reward state for a given LP token and a reward asset",
        "type": "object",
        "required": [
          "reward_state"
        ],
        "properties": {
          "reward_state": {
            "type": "object",
            "required": [
              "asset",
              "lp_token"
            ],
            "properties": {
              "asset": {
                "$ref": "#/definitions/AssetInfo"
              },
              "lp_token": {
                "$ref": "#/definitions/Addr"
              }
            },
            "additionalProperties": false
          }
        },
        "additionalProperties": false
      },
      {
        "description": "Returns the staking information for a given user based on the last interaction with the contract",
        "type": "object",
        "required": [
          "staker_info"
        ],
        "properties": {
          "staker_info": {
            "type": "object",
            "required": [
              "asset",
              "lp_token",
              "user"
            ],
            "properties": {
              "asset": {
                "$ref": "#/definitions/AssetInfo"
              },
              "lp_token": {
                "$ref": "#/definitions/Addr"
              },
              "user": {
                "$ref": "#/definitions/Addr"
              }
            },
            "additionalProperties": false
          }
        },
        "additionalProperties": false
      },
      {
        "description": "Returns the reward that the creator of a reward schedule can claim since no token was bonded in a part of the reward period",
        "type": "object",
        "required": [
          "creator_claimable_reward"
        ],
        "properties": {
          "creator_claimable_reward": {
            "type": "object",
            "required": [
              "reward_schedule_id"
            ],
            "properties": {
              "reward_schedule_id": {
                "type": "integer",
                "format": "uint64",
                "minimum": 0.0
              }
            },
            "additionalProperties": false
          }
        },
        "additionalProperties": false
      }
    ],
    "definitions": {
      "Addr": {
        "description": "A human readable address.\n\nIn Cosmos, this is typically bech32 encoded. But for multi-chain smart contracts no assumptions should be made other than being UTF-8 encoded and of reasonable length.\n\nThis type represents a validated address. It can be created in the following ways 1. Use `Addr::unchecked(input)` 2. Use `let checked: Addr = deps.api.addr_validate(input)?` 3. Use `let checked: Addr = deps.api.addr_humanize(canonical_addr)?` 4. Deserialize from JSON. This must only be done from JSON that was validated before such as a contract's state. `Addr` must not be used in messages sent by the user because this would result in unvalidated instances.\n\nThis type is immutable. If you really need to mutate it (Really? Are you sure?), create a mutable copy using `let mut mutable = Addr::to_string()` and operate on that `String` instance.",
        "type": "string"
      },
      "AssetInfo": {
        "description": "This enum describes available Token types.",
        "oneOf": [
          {
            "description": "Non-native Token",
            "type": "object",
            "required": [
              "token"
            ],
            "properties": {
              "token": {
                "type": "object",
                "required": [
                  "contract_addr"
                ],
                "properties": {
                  "contract_addr": {
                    "$ref": "#/definitions/Addr"
                  }
                },
                "additionalProperties": false
              }
            },
            "additionalProperties": false
          },
          {
            "description": "Native token",
            "type": "object",
            "required": [
              "native_token"
            ],
            "properties": {
              "native_token": {
                "type": "object",
                "required": [
                  "denom"
                ],
                "properties": {
                  "denom": {
                    "type": "string"
                  }
                },
                "additionalProperties": false
              }
            },
            "additionalProperties": false
          }
        ]
      }
    }
  },
  "migrate": {
    "$schema": "http://json-schema.org/draft-07/schema#",
    "title": "MigrateMsg",
    "oneOf": [
      {
        "type": "object",
        "required": [
          "v2"
        ],
        "properties": {
          "v2": {
            "type": "object",
            "required": [
              "instant_unbond_fee_percentage"
            ],
            "properties": {
              "instant_unbond_fee_percentage": {
                "description": "value between 0 and 10 (0% to 10%) are allowed",
                "type": "integer",
                "format": "uint64",
                "minimum": 0.0
              },
              "keeper_addr": {
                "anyOf": [
                  {
                    "$ref": "#/definitions/Addr"
                  },
                  {
                    "type": "null"
                  }
                ]
              }
            },
            "additionalProperties": false
          }
        },
        "additionalProperties": false
      }
    ],
    "definitions": {
      "Addr": {
        "description": "A human readable address.\n\nIn Cosmos, this is typically bech32 encoded. But for multi-chain smart contracts no assumptions should be made other than being UTF-8 encoded and of reasonable length.\n\nThis type represents a validated address. It can be created in the following ways 1. Use `Addr::unchecked(input)` 2. Use `let checked: Addr = deps.api.addr_validate(input)?` 3. Use `let checked: Addr = deps.api.addr_humanize(canonical_addr)?` 4. Deserialize from JSON. This must only be done from JSON that was validated before such as a contract's state. `Addr` must not be used in messages sent by the user because this would result in unvalidated instances.\n\nThis type is immutable. If you really need to mutate it (Really? Are you sure?), create a mutable copy using `let mut mutable = Addr::to_string()` and operate on that `String` instance.",
        "type": "string"
      }
    }
  },
  "sudo": null,
  "responses": {
    "allowed_l_p_tokens_for_reward": {
      "$schema": "http://json-schema.org/draft-07/schema#",
      "title": "Array_of_Addr",
      "type": "array",
      "items": {
        "$ref": "#/definitions/Addr"
      },
      "definitions": {
        "Addr": {
          "description": "A human readable address.\n\nIn Cosmos, this is typically bech32 encoded. But for multi-chain smart contracts no assumptions should be made other than being UTF-8 encoded and of reasonable length.\n\nThis type represents a validated address. It can be created in the following ways 1. Use `Addr::unchecked(input)` 2. Use `let checked: Addr = deps.api.addr_validate(input)?` 3. Use `let checked: Addr = deps.api.addr_humanize(canonical_addr)?` 4. Deserialize from JSON. This must only be done from JSON that was validated before such as a contract's state. `Addr` must not be used in messages sent by the user because this would result in unvalidated instances.\n\nThis type is immutable. If you really need to mutate it (Really? Are you sure?), create a mutable copy using `let mut mutable = Addr::to_string()` and operate on that `String` instance.",
          "type": "string"
        }
      }
    },
    "bonded_lp_tokens": {
      "$schema": "http://json-schema.org/draft-07/schema#",
      "title": "Uint128",
      "description": "A thin wrapper around u128 that is using strings for JSON encoding/decoding, such that the full u128 range can be used for clients that convert JSON numbers to floats, like JavaScript and jq.\n\n# Examples\n\nUse `from` to create instances of this and `u128` to get the value out:\n\n``` # use cosmwasm_std::Uint128; let a = Uint128::from(123u128); assert_eq!(a.u128(), 123);\n\nlet b = Uint128::from(42u64); assert_eq!(b.u128(), 42);\n\nlet c = Uint128::from(70u32); assert_eq!(c.u128(), 70); ```",
      "type": "string"
    },
    "config": {
      "$schema": "http://json-schema.org/draft-07/schema#",
      "title": "Config",
      "type": "object",
      "required": [
        "allowed_lp_tokens",
        "instant_unbond_fee_bp",
        "minimum_reward_schedule_proposal_start_delay",
        "owner",
        "unlock_period"
      ],
      "properties": {
        "allowed_lp_tokens": {
          "description": "LP Token addresses for which reward schedules can be added",
          "type": "array",
          "items": {
            "$ref": "#/definitions/Addr"
          }
        },
        "instant_unbond_fee_bp": {
          "description": "Instant LP unbonding fee. This is the percentage of the LP tokens that will be deducted as fee value between 0 and 1000 (0% to 10%) are allowed",
          "type": "integer",
          "format": "uint64",
          "minimum": 0.0
        },
        "keeper": {
          "description": "Keeper address that acts as treasury of the Dexter protocol. All the fees are sent to this address.",
          "anyOf": [
            {
              "$ref": "#/definitions/Addr"
            },
            {
              "type": "null"
            }
          ]
        },
        "minimum_reward_schedule_proposal_start_delay": {
          "description": "Minimum number of seconds after which a proposed reward schedule can start after it is proposed. This is to give enough time to review the proposal.",
          "type": "integer",
          "format": "uint64",
          "minimum": 0.0
        },
        "owner": {
          "description": "owner has privilege to add/remove allowed lp tokens for reward",
          "allOf": [
            {
              "$ref": "#/definitions/Addr"
            }
          ]
        },
        "unlock_period": {
          "description": "Unlocking period in seconds This is the minimum time that must pass before a user can withdraw their staked tokens and rewards after they have called the unbond function",
          "type": "integer",
          "format": "uint64",
          "minimum": 0.0
        }
      },
      "additionalProperties": false,
      "definitions": {
        "Addr": {
          "description": "A human readable address.\n\nIn Cosmos, this is typically bech32 encoded. But for multi-chain smart contracts no assumptions should be made other than being UTF-8 encoded and of reasonable length.\n\nThis type represents a validated address. It can be created in the following ways 1. Use `Addr::unchecked(input)` 2. Use `let checked: Addr = deps.api.addr_validate(input)?` 3. Use `let checked: Addr = deps.api.addr_humanize(canonical_addr)?` 4. Deserialize from JSON. This must only be done from JSON that was validated before such as a contract's state. `Addr` must not be used in messages sent by the user because this would result in unvalidated instances.\n\nThis type is immutable. If you really need to mutate it (Really? Are you sure?), create a mutable copy using `let mut mutable = Addr::to_string()` and operate on that `String` instance.",
          "type": "string"
        }
      }
    },
    "creator_claimable_reward": {
      "$schema": "http://json-schema.org/draft-07/schema#",
      "title": "CreatorClaimableRewardState",
      "type": "object",
      "required": [
        "amount",
        "claimed",
        "last_update"
      ],
      "properties": {
        "amount": {
          "$ref": "#/definitions/Uint128"
        },
        "claimed": {
          "type": "boolean"
        },
        "last_update": {
          "type": "integer",
          "format": "uint64",
          "minimum": 0.0
        }
      },
      "additionalProperties": false,
      "definitions": {
        "Uint128": {
          "description": "A thin wrapper around u128 that is using strings for JSON encoding/decoding, such that the full u128 range can be used for clients that convert JSON numbers to floats, like JavaScript and jq.\n\n# Examples\n\nUse `from` to create instances of this and `u128` to get the value out:\n\n``` # use cosmwasm_std::Uint128; let a = Uint128::from(123u128); assert_eq!(a.u128(), 123);\n\nlet b = Uint128::from(42u64); assert_eq!(b.u128(), 42);\n\nlet c = Uint128::from(70u32); assert_eq!(c.u128(), 70); ```",
          "type": "string"
        }
      }
    },
    "owner": {
      "$schema": "http://json-schema.org/draft-07/schema#",
      "title": "Addr",
      "description": "A human readable address.\n\nIn Cosmos, this is typically bech32 encoded. But for multi-chain smart contracts no assumptions should be made other than being UTF-8 encoded and of reasonable length.\n\nThis type represents a validated address. It can be created in the following ways 1. Use `Addr::unchecked(input)` 2. Use `let checked: Addr = deps.api.addr_validate(input)?` 3. Use `let checked: Addr = deps.api.addr_humanize(canonical_addr)?` 4. Deserialize from JSON. This must only be done from JSON that was validated before such as a contract's state. `Addr` must not be used in messages sent by the user because this would result in unvalidated instances.\n\nThis type is immutable. If you really need to mutate it (Really? Are you sure?), create a mutable copy using `let mut mutable = Addr::to_string()` and operate on that `String` instance.",
      "type": "string"
    },
    "proposed_reward_schedule": {
      "$schema": "http://json-schema.org/draft-07/schema#",
      "title": "ProposedRewardSchedule",
      "description": "The proposed reward schedule for a LP token",
      "type": "object",
      "required": [
        "asset",
        "end_block_time",
        "lp_token",
        "proposer",
        "rejected",
        "start_block_time",
        "title"
      ],
      "properties": {
        "asset": {
          "description": "The asset proposed as reward. The asset would go back to the proposer when the proposer drops the proposal.",
          "allOf": [
            {
              "$ref": "#/definitions/Asset"
            }
          ]
        },
        "description": {
          "description": "Any description that the proposer wants to give about the proposal.",
          "type": [
            "string",
            "null"
          ]
        },
        "end_block_time": {
          "description": "Block time when reward schedule ends.",
          "type": "integer",
          "format": "uint64",
          "minimum": 0.0
        },
        "lp_token": {
          "description": "The LP token for which to propose the reward schedule",
          "allOf": [
            {
              "$ref": "#/definitions/Addr"
            }
          ]
        },
        "proposer": {
          "description": "The proposer of the reward schedule",
          "allOf": [
            {
              "$ref": "#/definitions/Addr"
            }
          ]
        },
        "rejected": {
          "description": "True if proposal was rejected, false if proposal hasn't yet been reviewed. Once rejected, a proposal can't be reviewed again. It can only be dropped by the proposer.",
          "type": "boolean"
        },
        "start_block_time": {
          "description": "Block time when the reward schedule will become effective. This must be at least 3 days in future at the time of proposal to give enough time to review. This also acts as the expiry of the proposal. If time has elapsed after the start_block_time, then the proposal can't be approved by the admin. After that, it can only be rejected by the admin, or dropped by the proposer.",
          "type": "integer",
          "format": "uint64",
          "minimum": 0.0
        },
        "title": {
          "description": "The title of the proposal.",
          "type": "string"
        }
      },
      "additionalProperties": false,
      "definitions": {
        "Addr": {
          "description": "A human readable address.\n\nIn Cosmos, this is typically bech32 encoded. But for multi-chain smart contracts no assumptions should be made other than being UTF-8 encoded and of reasonable length.\n\nThis type represents a validated address. It can be created in the following ways 1. Use `Addr::unchecked(input)` 2. Use `let checked: Addr = deps.api.addr_validate(input)?` 3. Use `let checked: Addr = deps.api.addr_humanize(canonical_addr)?` 4. Deserialize from JSON. This must only be done from JSON that was validated before such as a contract's state. `Addr` must not be used in messages sent by the user because this would result in unvalidated instances.\n\nThis type is immutable. If you really need to mutate it (Really? Are you sure?), create a mutable copy using `let mut mutable = Addr::to_string()` and operate on that `String` instance.",
          "type": "string"
        },
        "Asset": {
          "title": "Description - This enum describes a asset (native or CW20).",
          "type": "object",
          "required": [
            "amount",
            "info"
          ],
          "properties": {
            "amount": {
              "description": "A token amount",
              "allOf": [
                {
                  "$ref": "#/definitions/Uint128"
                }
              ]
            },
            "info": {
              "description": "Information about an asset stored in a [`AssetInfo`] struct",
              "allOf": [
                {
                  "$ref": "#/definitions/AssetInfo"
                }
              ]
            }
          },
          "additionalProperties": false
        },
        "AssetInfo": {
          "description": "This enum describes available Token types.",
          "oneOf": [
            {
              "description": "Non-native Token",
              "type": "object",
              "required": [
                "token"
              ],
              "properties": {
                "token": {
                  "type": "object",
                  "required": [
                    "contract_addr"
                  ],
                  "properties": {
                    "contract_addr": {
                      "$ref": "#/definitions/Addr"
                    }
                  },
                  "additionalProperties": false
                }
              },
              "additionalProperties": false
            },
            {
              "description": "Native token",
              "type": "object",
              "required": [
                "native_token"
              ],
              "properties": {
                "native_token": {
                  "type": "object",
                  "required": [
                    "denom"
                  ],
                  "properties": {
                    "denom": {
                      "type": "string"
                    }
                  },
                  "additionalProperties": false
                }
              },
              "additionalProperties": false
            }
          ]
        },
        "Uint128": {
          "description": "A thin wrapper around u128 that is using strings for JSON encoding/decoding, such that the full u128 range can be used for clients that convert JSON numbers to floats, like JavaScript and jq.\n\n# Examples\n\nUse `from` to create instances of this and `u128` to get the value out:\n\n``` # use cosmwasm_std::Uint128; let a = Uint128::from(123u128); assert_eq!(a.u128(), 123);\n\nlet b = Uint128::from(42u64); assert_eq!(b.u128(), 42);\n\nlet c = Uint128::from(70u32); assert_eq!(c.u128(), 70); ```",
          "type": "string"
        }
      }
    },
    "proposed_reward_schedules": {
      "$schema": "http://json-schema.org/draft-07/schema#",
      "title": "Array_of_ProposedRewardSchedulesResponse",
      "type": "array",
      "items": {
        "$ref": "#/definitions/ProposedRewardSchedulesResponse"
      },
      "definitions": {
        "Addr": {
          "description": "A human readable address.\n\nIn Cosmos, this is typically bech32 encoded. But for multi-chain smart contracts no assumptions should be made other than being UTF-8 encoded and of reasonable length.\n\nThis type represents a validated address. It can be created in the following ways 1. Use `Addr::unchecked(input)` 2. Use `let checked: Addr = deps.api.addr_validate(input)?` 3. Use `let checked: Addr = deps.api.addr_humanize(canonical_addr)?` 4. Deserialize from JSON. This must only be done from JSON that was validated before such as a contract's state. `Addr` must not be used in messages sent by the user because this would result in unvalidated instances.\n\nThis type is immutable. If you really need to mutate it (Really? Are you sure?), create a mutable copy using `let mut mutable = Addr::to_string()` and operate on that `String` instance.",
          "type": "string"
        },
        "Asset": {
          "title": "Description - This enum describes a asset (native or CW20).",
          "type": "object",
          "required": [
            "amount",
            "info"
          ],
          "properties": {
            "amount": {
              "description": "A token amount",
              "allOf": [
                {
                  "$ref": "#/definitions/Uint128"
                }
              ]
            },
            "info": {
              "description": "Information about an asset stored in a [`AssetInfo`] struct",
              "allOf": [
                {
                  "$ref": "#/definitions/AssetInfo"
                }
              ]
            }
          },
          "additionalProperties": false
        },
        "AssetInfo": {
          "description": "This enum describes available Token types.",
          "oneOf": [
            {
              "description": "Non-native Token",
              "type": "object",
              "required": [
                "token"
              ],
              "properties": {
                "token": {
                  "type": "object",
                  "required": [
                    "contract_addr"
                  ],
                  "properties": {
                    "contract_addr": {
                      "$ref": "#/definitions/Addr"
                    }
                  },
                  "additionalProperties": false
                }
              },
              "additionalProperties": false
            },
            {
              "description": "Native token",
              "type": "object",
              "required": [
                "native_token"
              ],
              "properties": {
                "native_token": {
                  "type": "object",
                  "required": [
                    "denom"
                  ],
                  "properties": {
                    "denom": {
                      "type": "string"
                    }
                  },
                  "additionalProperties": false
                }
              },
              "additionalProperties": false
            }
          ]
        },
        "ProposedRewardSchedule": {
          "description": "The proposed reward schedule for a LP token",
          "type": "object",
          "required": [
            "asset",
            "end_block_time",
            "lp_token",
            "proposer",
            "rejected",
            "start_block_time",
            "title"
          ],
          "properties": {
            "asset": {
              "description": "The asset proposed as reward. The asset would go back to the proposer when the proposer drops the proposal.",
              "allOf": [
                {
                  "$ref": "#/definitions/Asset"
                }
              ]
            },
            "description": {
              "description": "Any description that the proposer wants to give about the proposal.",
              "type": [
                "string",
                "null"
              ]
            },
            "end_block_time": {
              "description": "Block time when reward schedule ends.",
              "type": "integer",
              "format": "uint64",
              "minimum": 0.0
            },
            "lp_token": {
              "description": "The LP token for which to propose the reward schedule",
              "allOf": [
                {
                  "$ref": "#/definitions/Addr"
                }
              ]
            },
            "proposer": {
              "description": "The proposer of the reward schedule",
              "allOf": [
                {
                  "$ref": "#/definitions/Addr"
                }
              ]
            },
            "rejected": {
              "description": "True if proposal was rejected, false if proposal hasn't yet been reviewed. Once rejected, a proposal can't be reviewed again. It can only be dropped by the proposer.",
              "type": "boolean"
            },
            "start_block_time": {
              "description": "Block time when the reward schedule will become effective. This must be at least 3 days in future at the time of proposal to give enough time to review. This also acts as the expiry of the proposal. If time has elapsed after the start_block_time, then the proposal can't be approved by the admin. After that, it can only be rejected by the admin, or dropped by the proposer.",
              "type": "integer",
              "format": "uint64",
              "minimum": 0.0
            },
            "title": {
              "description": "The title of the proposal.",
              "type": "string"
            }
          },
          "additionalProperties": false
        },
        "ProposedRewardSchedulesResponse": {
          "type": "object",
          "required": [
            "proposal",
            "proposal_id"
          ],
          "properties": {
            "proposal": {
              "$ref": "#/definitions/ProposedRewardSchedule"
            },
            "proposal_id": {
              "type": "integer",
              "format": "uint64",
              "minimum": 0.0
            }
          },
          "additionalProperties": false
        },
        "Uint128": {
          "description": "A thin wrapper around u128 that is using strings for JSON encoding/decoding, such that the full u128 range can be used for clients that convert JSON numbers to floats, like JavaScript and jq.\n\n# Examples\n\nUse `from` to create instances of this and `u128` to get the value out:\n\n``` # use cosmwasm_std::Uint128; let a = Uint128::from(123u128); assert_eq!(a.u128(), 123);\n\nlet b = Uint128::from(42u64); assert_eq!(b.u128(), 42);\n\nlet c = Uint128::from(70u32); assert_eq!(c.u128(), 70); ```",
          "type": "string"
        }
      }
    },
    "reward_schedules": {
      "$schema": "http://json-schema.org/draft-07/schema#",
      "title": "Array_of_RewardScheduleResponse",
      "type": "array",
      "items": {
        "$ref": "#/definitions/RewardScheduleResponse"
      },
      "definitions": {
        "Addr": {
          "description": "A human readable address.\n\nIn Cosmos, this is typically bech32 encoded. But for multi-chain smart contracts no assumptions should be made other than being UTF-8 encoded and of reasonable length.\n\nThis type represents a validated address. It can be created in the following ways 1. Use `Addr::unchecked(input)` 2. Use `let checked: Addr = deps.api.addr_validate(input)?` 3. Use `let checked: Addr = deps.api.addr_humanize(canonical_addr)?` 4. Deserialize from JSON. This must only be done from JSON that was validated before such as a contract's state. `Addr` must not be used in messages sent by the user because this would result in unvalidated instances.\n\nThis type is immutable. If you really need to mutate it (Really? Are you sure?), create a mutable copy using `let mut mutable = Addr::to_string()` and operate on that `String` instance.",
          "type": "string"
        },
        "AssetInfo": {
          "description": "This enum describes available Token types.",
          "oneOf": [
            {
              "description": "Non-native Token",
              "type": "object",
              "required": [
                "token"
              ],
              "properties": {
                "token": {
                  "type": "object",
                  "required": [
                    "contract_addr"
                  ],
                  "properties": {
                    "contract_addr": {
                      "$ref": "#/definitions/Addr"
                    }
                  },
                  "additionalProperties": false
                }
              },
              "additionalProperties": false
            },
            {
              "description": "Native token",
              "type": "object",
              "required": [
                "native_token"
              ],
              "properties": {
                "native_token": {
                  "type": "object",
                  "required": [
                    "denom"
                  ],
                  "properties": {
                    "denom": {
                      "type": "string"
                    }
                  },
                  "additionalProperties": false
                }
              },
              "additionalProperties": false
            }
          ]
        },
        "RewardSchedule": {
          "type": "object",
          "required": [
            "amount",
            "asset",
            "creator",
            "end_block_time",
            "staking_lp_token",
            "start_block_time",
            "title"
          ],
          "properties": {
            "amount": {
              "$ref": "#/definitions/Uint128"
            },
            "asset": {
              "$ref": "#/definitions/AssetInfo"
            },
            "creator": {
              "$ref": "#/definitions/Addr"
            },
            "end_block_time": {
              "type": "integer",
              "format": "uint64",
              "minimum": 0.0
            },
            "staking_lp_token": {
              "$ref": "#/definitions/Addr"
            },
            "start_block_time": {
              "type": "integer",
              "format": "uint64",
              "minimum": 0.0
            },
            "title": {
              "type": "string"
            }
          },
          "additionalProperties": false
        },
        "RewardScheduleResponse": {
          "type": "object",
          "required": [
            "id",
            "reward_schedule"
          ],
          "properties": {
            "id": {
              "type": "integer",
              "format": "uint64",
              "minimum": 0.0
            },
            "reward_schedule": {
              "$ref": "#/definitions/RewardSchedule"
            }
          },
          "additionalProperties": false
        },
        "Uint128": {
          "description": "A thin wrapper around u128 that is using strings for JSON encoding/decoding, such that the full u128 range can be used for clients that convert JSON numbers to floats, like JavaScript and jq.\n\n# Examples\n\nUse `from` to create instances of this and `u128` to get the value out:\n\n``` # use cosmwasm_std::Uint128; let a = Uint128::from(123u128); assert_eq!(a.u128(), 123);\n\nlet b = Uint128::from(42u64); assert_eq!(b.u128(), 42);\n\nlet c = Uint128::from(70u32); assert_eq!(c.u128(), 70); ```",
          "type": "string"
        }
      }
    },
    "reward_state": {
      "$schema": "http://json-schema.org/draft-07/schema#",
      "title": "AssetRewardState",
      "type": "object",
      "required": [
        "last_distributed",
        "reward_index"
      ],
      "properties": {
        "last_distributed": {
          "type": "integer",
          "format": "uint64",
          "minimum": 0.0
        },
        "reward_index": {
          "$ref": "#/definitions/Decimal"
        }
      },
      "additionalProperties": false,
      "definitions": {
        "Decimal": {
          "description": "A fixed-point decimal value with 18 fractional digits, i.e. Decimal(1_000_000_000_000_000_000) == 1.0\n\nThe greatest possible value that can be represented is 340282366920938463463.374607431768211455 (which is (2^128 - 1) / 10^18)",
          "type": "string"
        }
      }
    },
    "staker_info": {
      "$schema": "http://json-schema.org/draft-07/schema#",
      "title": "AssetStakerInfo",
      "type": "object",
      "required": [
        "asset",
        "pending_reward",
        "reward_index"
      ],
      "properties": {
        "asset": {
          "$ref": "#/definitions/AssetInfo"
        },
        "pending_reward": {
          "$ref": "#/definitions/Uint128"
        },
        "reward_index": {
          "$ref": "#/definitions/Decimal"
        }
      },
      "additionalProperties": false,
      "definitions": {
        "Addr": {
          "description": "A human readable address.\n\nIn Cosmos, this is typically bech32 encoded. But for multi-chain smart contracts no assumptions should be made other than being UTF-8 encoded and of reasonable length.\n\nThis type represents a validated address. It can be created in the following ways 1. Use `Addr::unchecked(input)` 2. Use `let checked: Addr = deps.api.addr_validate(input)?` 3. Use `let checked: Addr = deps.api.addr_humanize(canonical_addr)?` 4. Deserialize from JSON. This must only be done from JSON that was validated before such as a contract's state. `Addr` must not be used in messages sent by the user because this would result in unvalidated instances.\n\nThis type is immutable. If you really need to mutate it (Really? Are you sure?), create a mutable copy using `let mut mutable = Addr::to_string()` and operate on that `String` instance.",
          "type": "string"
        },
        "AssetInfo": {
          "description": "This enum describes available Token types.",
          "oneOf": [
            {
              "description": "Non-native Token",
              "type": "object",
              "required": [
                "token"
              ],
              "properties": {
                "token": {
                  "type": "object",
                  "required": [
                    "contract_addr"
                  ],
                  "properties": {
                    "contract_addr": {
                      "$ref": "#/definitions/Addr"
                    }
                  },
                  "additionalProperties": false
                }
              },
              "additionalProperties": false
            },
            {
              "description": "Native token",
              "type": "object",
              "required": [
                "native_token"
              ],
              "properties": {
                "native_token": {
                  "type": "object",
                  "required": [
                    "denom"
                  ],
                  "properties": {
                    "denom": {
                      "type": "string"
                    }
                  },
                  "additionalProperties": false
                }
              },
              "additionalProperties": false
            }
          ]
        },
        "Decimal": {
          "description": "A fixed-point decimal value with 18 fractional digits, i.e. Decimal(1_000_000_000_000_000_000) == 1.0\n\nThe greatest possible value that can be represented is 340282366920938463463.374607431768211455 (which is (2^128 - 1) / 10^18)",
          "type": "string"
        },
        "Uint128": {
          "description": "A thin wrapper around u128 that is using strings for JSON encoding/decoding, such that the full u128 range can be used for clients that convert JSON numbers to floats, like JavaScript and jq.\n\n# Examples\n\nUse `from` to create instances of this and `u128` to get the value out:\n\n``` # use cosmwasm_std::Uint128; let a = Uint128::from(123u128); assert_eq!(a.u128(), 123);\n\nlet b = Uint128::from(42u64); assert_eq!(b.u128(), 42);\n\nlet c = Uint128::from(70u32); assert_eq!(c.u128(), 70); ```",
          "type": "string"
        }
      }
    },
    "token_locks": {
      "$schema": "http://json-schema.org/draft-07/schema#",
      "title": "TokenLockInfo",
      "type": "object",
      "required": [
        "locks",
        "unlocked_amount"
      ],
      "properties": {
        "locks": {
          "type": "array",
          "items": {
            "$ref": "#/definitions/TokenLock"
          }
        },
        "unlocked_amount": {
          "$ref": "#/definitions/Uint128"
        }
      },
      "additionalProperties": false,
      "definitions": {
        "TokenLock": {
          "type": "object",
          "required": [
            "amount",
            "unlock_time"
          ],
          "properties": {
            "amount": {
              "$ref": "#/definitions/Uint128"
            },
            "unlock_time": {
              "type": "integer",
              "format": "uint64",
              "minimum": 0.0
            }
          },
          "additionalProperties": false
        },
        "Uint128": {
          "description": "A thin wrapper around u128 that is using strings for JSON encoding/decoding, such that the full u128 range can be used for clients that convert JSON numbers to floats, like JavaScript and jq.\n\n# Examples\n\nUse `from` to create instances of this and `u128` to get the value out:\n\n``` # use cosmwasm_std::Uint128; let a = Uint128::from(123u128); assert_eq!(a.u128(), 123);\n\nlet b = Uint128::from(42u64); assert_eq!(b.u128(), 42);\n\nlet c = Uint128::from(70u32); assert_eq!(c.u128(), 70); ```",
          "type": "string"
        }
      }
    },
    "unclaimed_rewards": {
      "$schema": "http://json-schema.org/draft-07/schema#",
      "title": "Array_of_UnclaimedReward",
      "type": "array",
      "items": {
        "$ref": "#/definitions/UnclaimedReward"
      },
      "definitions": {
        "Addr": {
          "description": "A human readable address.\n\nIn Cosmos, this is typically bech32 encoded. But for multi-chain smart contracts no assumptions should be made other than being UTF-8 encoded and of reasonable length.\n\nThis type represents a validated address. It can be created in the following ways 1. Use `Addr::unchecked(input)` 2. Use `let checked: Addr = deps.api.addr_validate(input)?` 3. Use `let checked: Addr = deps.api.addr_humanize(canonical_addr)?` 4. Deserialize from JSON. This must only be done from JSON that was validated before such as a contract's state. `Addr` must not be used in messages sent by the user because this would result in unvalidated instances.\n\nThis type is immutable. If you really need to mutate it (Really? Are you sure?), create a mutable copy using `let mut mutable = Addr::to_string()` and operate on that `String` instance.",
          "type": "string"
        },
        "AssetInfo": {
          "description": "This enum describes available Token types.",
          "oneOf": [
            {
              "description": "Non-native Token",
              "type": "object",
              "required": [
                "token"
              ],
              "properties": {
                "token": {
                  "type": "object",
                  "required": [
                    "contract_addr"
                  ],
                  "properties": {
                    "contract_addr": {
                      "$ref": "#/definitions/Addr"
                    }
                  },
                  "additionalProperties": false
                }
              },
              "additionalProperties": false
            },
            {
              "description": "Native token",
              "type": "object",
              "required": [
                "native_token"
              ],
              "properties": {
                "native_token": {
                  "type": "object",
                  "required": [
                    "denom"
                  ],
                  "properties": {
                    "denom": {
                      "type": "string"
                    }
                  },
                  "additionalProperties": false
                }
              },
              "additionalProperties": false
            }
          ]
        },
        "Uint128": {
          "description": "A thin wrapper around u128 that is using strings for JSON encoding/decoding, such that the full u128 range can be used for clients that convert JSON numbers to floats, like JavaScript and jq.\n\n# Examples\n\nUse `from` to create instances of this and `u128` to get the value out:\n\n``` # use cosmwasm_std::Uint128; let a = Uint128::from(123u128); assert_eq!(a.u128(), 123);\n\nlet b = Uint128::from(42u64); assert_eq!(b.u128(), 42);\n\nlet c = Uint128::from(70u32); assert_eq!(c.u128(), 70); ```",
          "type": "string"
        },
        "UnclaimedReward": {
          "type": "object",
          "required": [
            "amount",
            "asset"
          ],
          "properties": {
            "amount": {
              "$ref": "#/definitions/Uint128"
            },
            "asset": {
              "$ref": "#/definitions/AssetInfo"
            }
          },
          "additionalProperties": false
        }
      }
    }
  }
}
